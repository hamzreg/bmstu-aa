\chapter{Аналитическая часть}

В данном разделе будет изучена структура данных словарь и будут рассмотрены алгоритмы поиска в словаре.

\section{Словарь}

Обычные списки (массивы) представляют собой набор пронумерованных элементов, то есть, для обращения к какому-либо элементу списка необходимо указать его номер. Номер элемента в списке однозначно идентифицирует сам элемент. Но идентифицировать данные по числовым номерам не всегда оказывается удобно. Например, маршруты поездов в России идентифицируются численно-буквенным кодом (число и одна цифра), также численно-буквенным кодом идентифицируются авиарейсы, то есть для хранения информации о рейсах поездов или самолетов в качестве идентификатора удобно было бы использовать не число, а текстовую строку.

Структура данных, позволяющая идентифицировать ее элементы не по числовому индексу, а по произвольному, называется словарем или ассоциативным массивом \cite{dict}. Данная структура хранит пары вида ''ключ-значение''. При поиске возвращается значение, которое ассоциируется с данным ключом, или ''Пара не найдена'', если по данному ключу нет значений.

В данной лабораторной работе используется словарь фильмов и сериалов, в котором:
\begin{itemize}
	\item ключ - название фильма или сериала;
	\item значение - его рейтинг.
\end{itemize}

\section{Полный перебор}

Полный перебор \cite{search-full} - метод решения, при котором поочередно перебираются все ключи словаря, пока не будет найден нужный.

Чем дальше искомый ключ от начала словаря, тем выше трудоемкость алгоритма. Так, если в начале алгоритм затрагивает $b$ операций, а при сравнении $k$ операций, то:
\begin{itemize}
	\item элемент найден на первом сравнении за $b + k$ операций (лучший случай);
	\item элемент найден на $i$-ом сравнении за $b + i \cdot k$ операций;
	\item элемент найден на последнем сравнении за $b +  N \cdot k$ операций, где $N$ -- размер словаря (худший случай);
\end{itemize}

При этом средняя трудоемкость равна:

\begin{equation}
	f = b + k \cdot \left(1 + \frac{N}{2} - \frac{1}{N + 1}\right)
\end{equation}

\section{Бинарный поиск}

Бинарный поиск \cite{search-bin} - поиск в заранее отсортированном словаре, который заключается в сравнении элементов со средним на текущем этапе, и, если ключ меньше, то промежутком для поиска становится левая часть, иначе - правая часть.

Тогда случаи расположены следующим образом ($b$ -- кол-во операций алгоритма в начале):
\begin{itemize}
	\item элемент найден на первом сравнении с средним элементом - трудоемкость $b + \log_2 1$ (лучший случай);
	\item элемент найден на $i$-ом сравнении - трудоемкость $b + \log_2 i$;
	\item элемент найден на последнем сравнении - трудоёмкость $b +  \log_2 N$, где $N$ - размер словаря (худший случай);
\end{itemize}

\section{Сегментный поиск}

Идея поиска при помощи сегментов \cite{search-segments} заключается в разбиении словаря на части, в каждую из которых попадают все элементы с некоторым общим признаком - одинаковый первый символ, цифра, слово.

Обращение к сегменту равно сумме вероятностей обращения к его ключам. Пусть $P_i$ - вероятность обращения к $i$-ому сегменту, а $p_j$ - вероятность обращения к $j$-ому элементу $i$-ого сегмента. Тогда вероятность выбрать нужный сегмент высчитывается так 

\begin{equation}
	P_i = \sum_j p_j
\end{equation}

Затем ключи в каждом сегменте сортируются, чтобы внутри каждого сегмента можно было произвести бинарный поиск с сложностью $O(\log_2 k)$, где $k$ - количество ключей в сегменте.

То есть, сначала выбирается нужный сегмент, а затем в нем с помощью бинарного поиска ищется нужный ключ.

При этом случаи располагаются так:
\begin{itemize}
	\item первым выбран верный сегмент, а нужный элемент - серединный (лучший случай);
	\item нужный сегмент выбран последним, а поиск ключа в данном сегменте - $\log_2 N$, где $N$ - число элементов в сегменте (худший случай);
\end{itemize}

При этом средняя трудоемкость поиска $i$-го элемента:

\begin{equation}
	\sum_{i \in \Omega}{\left(f_{\text{выбор сегмента i-ого элемента}} + f_{\text{бинарный поиск i-ого элемента}}\right)} \cdot p_i
\end{equation}

\section{Вывод}

Была изучена структура данных - словарь. Были рассмотрены подходы к поиску в словаре.

Программе, реализующей данные алгоритмы, на вход должен подаваться словарь значений и ключ для поиска. Выходными данными такой программы должны быть значение по ключу и число сравнений, выполненных при поиске этого значения. Программа должна работать в рамках следующих ограничений: 

\begin{itemize}
	\item ключ должен быть непустой строкой;
	\item при пустом словаре или отсутствии данного ключа в словаре должно быть выдано соответствующее сообщение;
	\item должно быть выдано сообщение об ошибке при некорректном вводе параметров.
\end{itemize}

Пользователь должен иметь возможность выбора метода решения - полным перебором, бинарным поиском или сегментным поиском, и вывода результата на экран. Также должны быть реализованы сравнение алгоритмов по времени работы и числу сравнений при поиске и получение графического представления результатов сравнения. Данные действия пользователь должен выполнять при помощи меню.